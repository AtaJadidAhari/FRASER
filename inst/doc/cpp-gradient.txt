includesrc <- '

void printv(SEXP x){
    //print(x);
}

void prints(std::string s){
    printv(Rcpp::wrap(s));
}

void printmat(arma::mat x){
    printv(Rcpp::wrap(x.n_cols));
    printv(Rcpp::wrap(x.n_rows));
    if(x.n_rows >= 1){
        printv(Rcpp::wrap(x.head_rows(5)));
    } else {
        prints("No rows exists here!");
    }
    return;
}

void printrv(arma::rowvec v){
    printv(Rcpp::wrap(v));
}

void printvec(arma::vec v){
    printv(Rcpp::wrap(v));
    //.head(std::min(v.n_elem-0.1, 5 - 0.1) + 0.1))
}

void printd(double x){
    printv(Rcpp::wrap(x));
}

const double epsilonU      = 0.000001
const double MAX_EXP_VALUE = 700;

arma::mat minValForExp(arma::mat y){
    arma::uvec idx;

    idx = find(y > MAX_EXP_VALUE);
    y.elem(idx).fill(MAX_EXP_VALUE);

    idx = find(y < -MAX_EXP_VALUE);
    y.elem(idx).fill(-MAX_EXP_VALUE);

    return y;
}

arma::vec swapInfWithval(arma::vec x, double val=36.7369, bool max=false){
    arma::uvec idx;

    idx = arma::find_nonfinite(x);
    x.elem(idx).fill(val);

    if(max == true){
        idx = find(x > val);
        x.elem(idx).fill(val);
    }
    return x;
}

arma::vec colMeans(arma::mat X){
    return arma::vectorise(arma::sum(X,0))/X.n_rows;
}

arma::vec mydigamma(arma::vec x){
    NumericVector myVec = digamma(as<NumericVector>(wrap(x)));
    return as<arma::vec>(wrap(myVec));
}

// [[Rcpp::export()]]
double truncNLL_db(arma::vec par, arma::mat H, arma::vec k, arma::vec n, double rho){
    double b, rhoa, rhob;
    arma::vec d, y, ey, p, u, v, alpha, alphaK, beta, betaNK, nll;

    b = par.at(0);
    d = par.subvec(1, par.n_elem-1);


    printd(b);
    printvec(d);

    y = H * d + b;
    y = minValForExp(y);
    ey = arma::exp(y);

    printmat(ey);

    rhoa = (1 - rho)/rho;
    rhob = (rho - 1)/rho;
    p    = ey/(1 + ey);
    u    = -1/(1 + ey) * rhob;
    v    = ey/arma::square(1 + ey);

    printmat(v);
    printmat(p);

    alpha  = arma::lgamma(p * rhoa);
    alphaK = arma::lgamma(p * rhoa + k);
    beta   = arma::lgamma(u + epsilonU);
    betaNK = arma::lgamma(u + n - k + epsilonU);

    beta <- swapInfWithval(beta);
    betaNK <- swapInfWithval(betaNK, 744.0, true);

    prints("alpha");
    printvec(u);
    printvec(beta);
    printvec(betaNK);

    nll = arma::accu(alpha + beta - alphaK - betaNK)/k.n_elem;

    return arma::as_scalar(nll);
}


// [[Rcpp::export()]]
arma::vec truncGrad_db(arma::vec par, arma::mat H, arma::vec k, arma::vec n, double rho){
    double b, rhoa, rhob;
    arma::vec d, y, ey, p, u, v, alpha, alphaK, beta, betaNK, grb, grd;

    b = par.at(0);
    d = par.subvec(1, par.n_elem-1);

    y = H * d + b;
    y = minValForExp(y);
    ey = arma::exp(y);

    rhoa = (1 - rho)/rho;
    rhob = (rho - 1)/rho;
    p    = ey/(1 + ey);
    u    = -1/(1 + ey) * rhob;
    v    = ey/arma::square(1 + ey);

    alpha  = mydigamma(p * rhoa) * rhoa;
    alphaK = mydigamma(p * rhoa + k) * rhoa;
    beta   = mydigamma(u + epsilonU) * rhob;
    betaNK = mydigamma(u + n - k + epsilonU) * rhob;

    beta <- swapInfWithval(beta);
    betaNK <- swapInfWithval(betaNK, 744.0, true);

    grb = arma::accu((alpha + beta - alphaK - betaNK) % v)/k.n_elem;
    grd = (alpha + beta - alphaK - betaNK) % v;
    grd = colMeans(grd % H.each_col());

    arma::mat ans = arma::join_cols(grb, grd);
    return ans.col(0);
}
'

### # define the body of the C/C++ program
cppBodyNll <- '
return Rcpp::wrap(truncNLL_db(Rcpp::as<arma::vec>(par), Rcpp::as<arma::mat>(H),
    Rcpp::as<arma::vec>(k), Rcpp::as<arma::vec>(n), Rcpp::as<double>(rho)));
'
cppBodyGrad <- '
return Rcpp::wrap(truncGrad_db(Rcpp::as<arma::vec>(par), Rcpp::as<arma::mat>(H),
    Rcpp::as<arma::vec>(k), Rcpp::as<arma::vec>(n), Rcpp::as<double>(rho)));
'


### # pass the above C/C++ function as an argument
### # to cxxfunction()
cppgr <- inline::cxxfunction(sig = signature(par = "vec", H = "mat", k="vec", n="vec", rho="double"),
                              plugin = "RcppArmadillo",
                              incl = includesrc,
                              body = cppBodyGrad)
cppnll <- inline::cxxfunction(sig = signature(par = "vec", H = "mat", k="vec", n="vec", rho="double"),
                              plugin = "RcppArmadillo",
                              incl = includesrc,
                              body = cppBodyNll)


a  <- cppnll(par=par, k=ki, n=ni, H=H, rho=rhoi)
gr <- cppgr( par=par, k=ki, n=ni, H=H, rho=rhoi)
gr

