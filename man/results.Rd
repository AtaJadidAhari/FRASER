% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R
\name{results,FraserDataSet-method}
\alias{results,FraserDataSet-method}
\alias{aberrant,FraserDataSet-method}
\title{Extracting results and aberrant splicing events}
\usage{
\S4method{results}{FraserDataSet}(
  object,
  sampleIDs = samples(object),
  padjCutoff = 0.05,
  zScoreCutoff = NA,
  deltaPsiCutoff = 0.1,
  rhoCutoff = 1,
  aggregate = FALSE,
  collapse = FALSE,
  minCount = 5,
  psiType = psiTypes,
  geneColumn = "hgnc_symbol",
  additionalColumns = NULL,
  BPPARAM = bpparam()
)

\S4method{aberrant}{FraserDataSet}(
  object,
  type = fitMetrics(object),
  padjCutoff = 0.05,
  deltaPsiCutoff = 0.1,
  zScoreCutoff = NA,
  minCount = 5,
  rhoCutoff = 1,
  by = c("none", "sample", "feature"),
  aggregate = FALSE,
  geneColumn = "hgnc_symbol",
  ...
)
}
\arguments{
\item{object}{A \code{\link{FraserDataSet}} object}

\item{sampleIDs}{A vector of sample IDs for which results should be 
retrieved}

\item{padjCutoff}{The FDR cutoff to be applied or NA if not requested.}

\item{zScoreCutoff}{The z-score cutoff to be applied or NA if not requested.}

\item{deltaPsiCutoff}{The cutoff on delta psi or NA if not requested.}

\item{rhoCutoff}{The cutoff value on the fitted rho value 
(overdispersion parameter of the betabinomial) above which 
junctions are filtered}

\item{aggregate}{If TRUE the returned object is aggregated to the feature 
level (i.e. gene level).}

\item{collapse}{Only takes effect if \code{aggregate=TRUE}. 
If TRUE, collapses results across the different psi 
types to return only one row per feature (gene) and sample.}

\item{minCount}{The minimum count value of the total coverage of an intron 
to be considered as significant.
result}

\item{psiType}{The psi types for which the results should be retrieved.}

\item{geneColumn}{The column name of the column that has the gene annotation 
that will be used for gene-level pvalue computation.}

\item{additionalColumns}{Character vector containing the names of additional 
columns from mcols(fds) that should appear in the result table 
(e.g. ensembl_gene_id). Default is \code{NULL}, so no additional columns 
are included.}

\item{BPPARAM}{The BiocParallel parameter.}

\item{type}{Splicing type (psi5, psi3 or theta)}

\item{by}{By default \code{none} which means no grouping. But if 
\code{sample} or \code{feature} is specified the sum by 
sample or feature is returned}

\item{...}{Further arguments can be passed to the method. If "n", "zscores", 
"padjVals", "dPsi" or "rhoVals" are given, the values of those 
arguments are used to define the aberrant events.}
}
\value{
For \code{results}: GRanges object containing significant results.
    For \code{aberrant}: Either a of logical values of size 
    introns/genes x samples if "by" is NA or a vector with the 
    number of aberrant events per sample or feature depending on 
    the vaule of "by"
}
\description{
The result function extracts the results from the given analysis object
based on the given options and cutoffs. The aberrant function extracts 
aberrant splicing events based on the given cutoffs.
}
\examples{
# get data, fit and compute p-values and z-scores
fds <- createTestFraserDataSet()

# extract results: for this example dataset, no cutoffs are used to
# get at least one result and show the output
res <- results(fds, padjCutoff=NA, zScoreCutoff=NA, deltaPsiCutoff=NA)
res

# aggregate the results by genes (gene symbols need to be annotated first 
# using annotateRanges() function)
results(fds, padjCutoff=NA, zScoreCutoff=1, deltaPsiCutoff=0.1, 
        aggregate=TRUE)

# aggregate the results by genes and collapse over all psi types to obtain 
# only one row per gene in the results table 
results(fds, padjCutoff=NA, zScoreCutoff=1, deltaPsiCutoff=0.1, 
        aggregate=TRUE, collapse=TRUE)

# get aberrant events per sample: on the example data, nothing is aberrant
# based on the adjusted p-value
aberrant(fds, type="jaccard", by="sample")

# get aberrant events per gene (first annotate gene symbols)
fds <- annotateRangesWithTxDb(fds)
aberrant(fds, type="jaccard", by="feature", zScoreCutoff=2, padjCutoff=NA,
        aggregate=TRUE)
        
# find aberrant junctions/splice sites
aberrant(fds, type="jaccard")
}
