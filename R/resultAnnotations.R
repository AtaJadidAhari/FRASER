#' 
#' @title Result annotations
#' 
#' @description These functions work on the result table and add additional 
#'     annotations to the reported junctions: the type of splice event (e.g. 
#'     exon skipping, intron retention, ...), as well as a flag for junctions 
#'     that are located in blacklist regions of the genome.
#' 
#' \code{\link{annotateSpliceEventType}} annotates each junction in the results 
#'     table with the type of splice event: exon skipping, 
#' 
#' \code{\link{flagBlacklistRegions}} flags junction in the results table on 
#'     whether or not they are located in a blacklist region of the genome. 
#'
#' @param result A result table as generated by FRASER.
#' @param fds The FraserDataSet, which was used to generate the results table
#' @param txdb A txdb object providing the reference annotation.
#' @params blacklist_regions BED file that contains the blacklist regions. 
#'     If \code{NULL} (default), the BED files that are packaged with FRASER are used.
#' @param assemblyVersion Indicates the genome assembly of the junction 
#'     coordinates. Only used if blacklist_regions is NULL.
#' @param BPPARAM For controlling parallelization behavior. 
#'     Defaults to \code{bpparam()}.
#' @return annotated results table
#' 
#' @name spliceTypeAnnotations
#' @rdname spliceTypeAnnotations
#' 
#' @examples
#'   # get data, fit and compute p-values and z-scores
#'   fds <- createTestFraserDataSet()
#' 
#'   # extract results: for this example dataset, z score cutoff of 2 is used to
#'   # get at least one result
#'   res <- results(fds, padjCutoff=NA, zScoreCutoff=3, deltaPsiCutoff=0.05)
#'   res_dt <- as.data.table(res)
#'   
#'   # annotate type of splice event
#'   requireNamespace("TxDb.Hsapiens.UCSC.hg19.knownGene")
#'   txdb <- 
#'     TxDb.Hsapiens.UCSC.hg19.knownGene::TxDb.Hsapiens.UCSC.hg19.knownGene 
#'   res_dt <- annotateSpliceEventType(fds, res_dt, txdb)
#'   
#'   # annotate blacklist regions
#'   res_dt <- flagBlacklistRegions(res_dt, assemblyVersion="hg19")
#'   
#'   # show annoated results table
#'   res_dt
#'   
NULL

#' @describeIn spliceTypeAnnotations This method annotates the splice event 
#'     type to junctions in the given results table.
#' @export
annotateSpliceEventType <- function(result, fds, txdb, BPPARAM=bpparam()){
    
    # Create basic annotation of overlap with reference
    fds <- annotateJunctionReferenceOverlap(fds, txdb, BPPARAM)
    
    # Calculate splice types and frameshift
    result <- aberrantSpliceType(result, fds, txdb)
    
    # Add the subtypes for exonSkipping and inconclusive
    result <- checkExonSkipping(result, txdb)
    result <- checkInconclusive(result, txdb)
    
    # Add UTR labels
    result <- addUTRLabels(result, txdb)
    
    return(result)
}

#' @describeIn spliceTypeAnnotations This method flags blacklist regions in 
#'     the given results table. 
#' @export
flagBlacklistRegions <- function(result, blacklist_regions=NULL,
                                assemblyVersion=c('hg19', 'hg38')){
    
    assemblyVersion <- match.arg(assemblyVersion)
    if(is.null(blacklist_regions)){
        blacklist_regions <- 
            system.file("extdata", "blacklist_regions", 
                        paste0(assemblyVersion, "-blacklist.v2.bed.gz"), 
                        package = "FRASER")
    }
    if(!file.exists(blacklist_regions)){
        stop("BED file with blacklist regions does not exist: ", 
            blacklist_regions)
    }
    print("Importing blacklist regions ...")
    blacklist_gr <- import(blacklist_regions, format = "BED")
    result <- addBlacklistLabels(result, blacklist_gr, "splicing")  
    return(result)
}

############# helper functions ##############################

#' blacklist annotation for aberrant splicing events  
#' @noRd
addBlacklistLabels <- function(junctions_dt, blacklist_gr){
    # add the blacklist information
    print("Set up aberrant splicing granges")
    psi_positions <- which(junctions_dt$type != "theta")
    colnames(junctions_dt)[which(names(junctions_dt) == "STRAND")] <- "strand2"
    junctions_gr <- makeGRangesFromDataFrame(junctions_dt[psi_positions])
    
    # set to the same seqlevelsstyle
    seqlevelsStyle(blacklist_gr) <- seqlevelsStyle(junctions_gr)
    
    ## create overlap with blacklist and annotate extra column
    print("find blacklist overlap")
    black_hits <- unique(from(findOverlaps(junctions_gr, blacklist_gr)))
    junctions_dt[, blacklist := FALSE]
    
    junctions_dt[psi_positions[black_hits], blacklist := TRUE]
    colnames(junctions_dt)[which(names(junctions_dt) == "strand2")] <- "STRAND"
    
    print("blacklist labels done")
    return(junctions_dt)
}

#' UTR annotation to results table
#' @noRd
addUTRLabels <- function(junctions_dt, txdb){
    psi_positions <- which(junctions_dt$type != "theta")
    colnames(junctions_dt)[which(names(junctions_dt) == "STRAND")] <- "strand2"
    junctions_gr <- makeGRangesFromDataFrame(junctions_dt[psi_positions])
    seqlevelsStyle(txdb) <- seqlevelsStyle(junctions_gr)
    ### UTR labels based on txdb file
    ### add 5' 3' UTR labels
    print("find UTR overlap")
    threes <- unique(from(findOverlaps(junctions_gr, 
                            threeUTRsByTranscript(txdb, use.names = TRUE))))
    fives <- unique(from(findOverlaps(junctions_gr, 
                            fiveUTRsByTranscript(txdb, use.names = TRUE))))
    junctions_dt[psi_positions, UTR := "no"]
    junctions_dt[psi_positions[threes], UTR := "3"]
    junctions_dt[psi_positions[fives], UTR := "5"]
    colnames(junctions_dt)[which(names(junctions_dt) == "strand2")] <- "STRAND"
    print("UTR labels done")
    return(junctions_dt)
}

#' Basic annotations of overlap with reference (start, end, none, both) for 
#' full fds.
#' @noRd
annotateJunctionReferenceOverlap <- function(fds, txdb, BPPARAM){
    print("loading introns")
    #seqlevelsStyle(fds) <- seqlevelsStyle(txdb)[1]
    introns <- unique(unlist(intronsByTranscript(txdb)))
    # reduce the introns to only the actually expressed introns
    fds_known <- fds[unique(to(findOverlaps(introns, 
                            rowRanges(fds, type = "j"), type = "equal"))),]
    anno_introns <- as.data.table(rowRanges(fds_known, 
                            type="j"))[,.(seqnames, start, end, strand)]
    
    # calculate extra columns with mean/median intron expression count
    # add the new columns
    print("adding median count to introns")
    sampleCounts <- K(fds_known, type = "j")
    anno_introns[, meanCount := rowMeans(sampleCounts)]
    anno_introns[, medianCount := rowMedians(as.matrix(sampleCounts))]
    # order by medianCount (highest first)
    setorderv(anno_introns, "medianCount", order=-1) 
    anno_introns_ranges <- makeGRangesFromDataFrame(anno_introns, 
                                                    keep.extra.columns = TRUE)
    
    # get all fds junctions
    fds_junctions <- rowRanges(fds, type = "j")
    
    # Do the annotation just for the intron with highest median expression
    print("start calculating annotations")    
    overlaps <- findOverlaps(fds_junctions, anno_introns_ranges, select="first")
    annotations <- bplapply(1:length(fds_junctions), function(i){
        # only select first intron as already ordered by medianCount beforehand
        overlap <- overlaps[i]
        if(is.na(overlap)) return("none") #no overlap with any intron
        
        hit_equal <- from(findOverlaps(fds_junctions[i], 
                                        anno_introns_ranges[overlap], 
                                        type="equal"))
        if(length(hit_equal) > 0) return("both")
        
        hit_start <- from(findOverlaps(fds_junctions[i], 
                                        anno_introns_ranges[overlap], 
                                        type="start"))
        if(length(hit_start) > 0) return("start")
        hit_end   <- from(findOverlaps(fds_junctions[i], 
                                        anno_introns_ranges[overlap], 
                                        type="end"))
        if(length(hit_end) > 0) return("end")
        
        # overlaps but no start/end match
        return("none") 
    }, BPPARAM=BPPARAM) 
    annotations <- unlist(annotations)
    
    rowRanges(fds)$annotatedJunction <- annotations
    mcols(fds, type="ss")$annotatedJunction <- "none"
    print("annotations done")
    return(fds)
}

#' 
#' @noRd
aberrantSpliceType <- function(junctions_dt, fds, txdb){
    print("preparing ...")
    psi_positions <- which(junctions_dt$type != "theta")
    colnames(junctions_dt)[which(names(junctions_dt) == "STRAND")] <- "strand2"
    junctions_gr <- makeGRangesFromDataFrame(junctions_dt[psi_positions], 
                                                keep.extra.columns = T)
    seqlevelsStyle(txdb) <- seqlevelsStyle(junctions_gr)
    
    introns_tmp <- unique(unlist(intronsByTranscript(txdb)))
    exons <- exons(txdb)
    
    # seqlevelsStyle(fds) <- seqlevelsStyle(txdb)[1]
    fds_known <- fds[unique(to(findOverlaps(introns_tmp, 
                                            rowRanges(fds, type = "j"), 
                                            type = "equal"))),]
    grIntrons <- rowRanges(fds_known, type="j")
    introns <- as.data.table(grIntrons)
    introns <- introns[,.(seqnames, start, end, strand)]
    
    sampleCounts <- K(fds_known, type = "j")
    introns[, "meanCount" := rowMeans(sampleCounts)]
    introns[, "medianCount" := rowMedians(as.matrix(sampleCounts))]
    intron_ranges <- makeGRangesFromDataFrame(introns, 
                                                keep.extra.columns = TRUE)
    
    # prepare the results column
    junctions_dt[, aberrantSpliceType := "NA"]
    junctions_dt[, causesFrameshift := "NA"]
    junctions_dt[which(junctions_dt$annotatedJunction=="both"), 
                    aberrantSpliceType := "sameIntron"]
    junctions_dt[which(junctions_dt$annotatedJunction=="both"), 
                    causesFrameshift := "unlikely"]
    
    starts <- which(junctions_dt[psi_positions]$annotatedJunction=="start")
    ends <- which(junctions_dt[psi_positions]$annotatedJunction=="end")
    nones <- which(junctions_dt[psi_positions]$annotatedJunction=="none")
    
    print("calculating aberrant splice types")
    print("start junctions")
    start_results <- sapply(starts, function(i){
        # find the most freq intron that overlaps again
        overlap <- to(findOverlaps(junctions_gr[i], intron_ranges, 
                                    type = "start"))
        expre <- sapply(overlap, function(j){
            elementMetadata(intron_ranges[j])$medianCount
        })
        maxExpr <- which.max(expre)
        return(compareEnds(junctions_gr, i, overlap[maxExpr], F, 
                            intron_ranges, exons))
    })
    junctions_dt[psi_positions[starts], 
                    causesFrameshift:=start_results[2,]]
    junctions_dt[psi_positions[starts], 
                    aberrantSpliceType := start_results[1,]]
    
    print("end junctions")
    end_results <- sapply(ends, function(i){
        # find the most freq intron that overlaps again
        overlap <- to(findOverlaps(junctions_gr[i], intron_ranges, 
                                    type = "end"))
        expre <- sapply(overlap, function(j){
            elementMetadata(intron_ranges[j])$medianCount
        })
        maxExpr <- which.max(expre)
        return(compareStarts(junctions_gr, i, overlap[maxExpr], F, 
                                intron_ranges, exons))
        
    })
    junctions_dt[psi_positions[ends], causesFrameshift:=end_results[2,]]
    junctions_dt[psi_positions[ends], aberrantSpliceType := end_results[1,]]
    
    print("none junctions pt1")
    none_results <- sapply(nones, function(i){
        # find most freq intron
        # check start and end
        
        # find the most freq intron that overlaps again
        overlap <- to(findOverlaps(junctions_gr[i], intron_ranges))
        if(length(overlap) == 0) return(c("noOverlap", "inconclusive"))
        expre <- sapply(overlap, function(j){
            elementMetadata(intron_ranges[j])$medianCount
        })
        maxExpr <- which.max(expre)
        
        # returns type of exon splicing, frameshift T/F, amount of shift
        st = compareStarts(junctions_gr, i, overlap[maxExpr], T, 
                            intron_ranges, exons)
        en = compareEnds(junctions_gr, i, overlap[maxExpr], T, 
                            intron_ranges, exons)
        
        # merge, start and end results
        # merge exon elongation/truncation
        # if both likely/unlikely fine
        # if one is likely -> return likely
        # if one is notYet -> return notYet
        if((st[1] == "singleExonSkipping" & !(en[1] %in% 
                                c("singleExonSkipping", "exonSkipping"))) ||
           (en[1] == "singleExonSkipping" & !(st[1] %in% 
                                c("singleExonSkipping", "exonSkipping")))){
            ## only one is single exonSkipping, the other is trunc/elong
            if((as.integer(st[3])+as.integer(en[3])) %% 3 != 0){
                frs = "likely"
            }else{ frs = "unlikely"}
            return(c("singleExonSkipping", frs))
        } 
        
        if(st[1] %in% c("exonSkipping", "singleExonSkipping") || en[1] %in% 
                c("exonSkipping", "singleExonSkipping")){
            return(c("exonSkipping", "inconclusive")) 
        }
        
        if((as.integer(st[3])+as.integer(en[3]))%%3 != 0){
            frs = "likely"
        }else{ frs = "unlikely"}
        if( st[1] != en[1]){
            combined = "trunc, elong"
        }else{combined = st[1]}
        return(c(combined,frs))
        
    })
    junctions_dt[psi_positions[nones], causesFrameshift:=none_results[2,]]
    junctions_dt[psi_positions[nones], aberrantSpliceType := none_results[1,]]
    
    noLaps <-which(junctions_dt[psi_positions]$aberrantSpliceType=="noOverlap")
    refseq.genes<- genes(txdb)
    
    print("none junctions pt2")
    noLaps_results <- sapply(noLaps, function(i){
        overlap <- to(findOverlaps(junctions_gr[i], exons))
        # no overlap with an intron or an exon
        if(length(overlap) == 0){
            return(checkIntergenic(junctions_gr, i, refseq.genes)) 
        }
        
        # for the exons, check if splice site is contained in the exon
        for(j in overlap){
            exon_start = start(exons[j])
            exon_end = end(exons[j])
            if(exon_start <= start(junctions_gr[i]) & 
                    exon_end >= end(junctions_gr[i])){
                if((end(junctions_gr[i]) - 
                        start(junctions_gr[i]) + 1) %% 3 != 0){
                    frs = "likely"
                }else{ frs = "unlikely"}
                return(c("exonTruncation", frs))
            }
        }
        
        return(c("inconclusive","inconclusive"))
    })
    junctions_dt[psi_positions[noLaps], 
                    causesFrameshift:=noLaps_results[2,]]
    junctions_dt[psi_positions[noLaps], 
                    aberrantSpliceType := noLaps_results[1,]]
    
    
    # add distance to closest neighbour gene for intergenic results
    print("adding distances to nearest gene")
    up <- which(junctions_dt[psi_positions]$aberrantSpliceType == "upstream")
    down <- which(junctions_dt[psi_positions
                                ]$aberrantSpliceType == "downstream")
    print("Calculate distances")
    
    if(length(up) > 0){
        distanceNearestGene_up <- sapply(up, function(i){
            min(distance(junctions_gr[i], refseq.genes), na.rm = T)})
        if(length(distanceNearestGene_up > 0)){
            junctions_dt[psi_positions[up], 
                            distNearestGene := distanceNearestGene_up]
        } else{
            junctions_dt[psi_positions[up], distNearestGene := NA]
            print("No distances found for upstream")
        }
    }else{print("No upstream targets")}
    
    if(length(down) > 0){
        distanceNearestGene_down <- sapply(down, function(i){
            min(distance(junctions_gr[i], refseq.genes), na.rm = T)})
        if(length(distanceNearestGene_down > 0)){
            junctions_dt[psi_positions[down], 
                            distNearestGene := distanceNearestGene_down]
        }else{
            junctions_dt[psi_positions[down], distNearestGene := NA]
            print("No distances found for downstream")
        }
    }else{print("No downstream targets")}
    
    colnames(junctions_dt)[which(names(junctions_dt) == "strand2")] <- "STRAND"
    print("done calculating aberrant splice types")
    return(junctions_dt)
}

#' 
#' @noRd
compareStarts <- function(junctions_gr, i, max_lap, shift_needed, 
                            intron_ranges, exons){
    intron_start = start(intron_ranges[max_lap])
    ss_start = start(junctions_gr[i])
    
    # found the most freq intron with same end again
    # check if intron starts before splice site -> exon elongation -> FRS 
    if(intron_start < ss_start){
        if(((ss_start - intron_start) %% 3) != 0){
            frs = "likely"
        }else{ frs = "unlikely"}
        
        ifelse(shift_needed, 
                return(c("exonElongation", frs, 
                            (ss_start - intron_start))), 
                return(c("exonElongation", frs)))
    }
    
    # check if splice site ends in following exon -> exon truncation -> FRS
    if(intron_start > ss_start){
        
        # create dummy exon find all exons starting from that intron end
        dummy_exon <- GRanges(
            seqnames = toString(seqnames(intron_ranges[max_lap])),
            ranges = IRanges(intron_start-2, end = intron_start -1),
            strand = toString(strand(intron_ranges[max_lap]))
        )
        exonChoices <- to(findOverlaps(dummy_exon, exons, type = "end"))
        for(j in exonChoices){
            exon_start = start(exons[j])
            if(exon_start < ss_start){
                if((end(exons[j]) - ss_start + 1)%%3 != 0){
                    frs = "likely"
                }else{frs = "unlikely"}
                ifelse(shift_needed, 
                        return(c("exonTruncation", frs, 
                                    (-1)*(end(exons[j]) - ss_start + 1))), 
                        return(c("exonTruncation", frs)))
            }
        }
        
        # check for single exon skipping
        if(length(exonChoices) == 1){
            
            # check if there is no other exon within the first intron: 
            # splice site end until exon end
            dummyFirstItr <- GRanges(
                seqnames = toString(seqnames(intron_ranges[max_lap])),
                ranges = IRanges(end(exons[exonChoices[1]]) + 1, 
                                end(junctions_gr[i])),
                strand = toString(strand(intron_ranges[max_lap]))
            )
            
            if(length(findOverlaps(exons, dummyFirstItr, 
                                    type = "within")) > 0){
                # another exon is contained within the most freq used intron
                ifelse(shift_needed, 
                        return(c("exonSkipping", "inconclusive", 0)), 
                        return(c("exonSkipping", "inconclusive")))
            }
            
            
            secondItr <- GRanges(
                seqnames = toString(intron_ranges[max_lap]@seqnames@values),
                strand = toString(intron_ranges[max_lap]@strand@values),
                ranges = IRanges(ss_start, start(exons[exonChoices[1]]) - 1) 
                # end of exon + 1, end of aberrant junction
            )
            secItrChoices <- to(findOverlaps(secondItr, intron_ranges, 
                                            type = "end"))
            # only look at most used one
            expre <- sapply(secItrChoices, function(j){
                elementMetadata(intron_ranges[j])$medianCount
            })
            maxExpr <- which.max(expre)
            
            if(length(secItrChoices) == 0){
                ifelse(shift_needed, 
                        return(c("exonSkipping", "inconclusive", 0)), 
                        return(c("exonSkipping", "inconclusive")))
            }
            
            if(ss_start >= start(intron_ranges[secItrChoices[maxExpr]])){
                # check if there is no other exon in that range
                if(length(findOverlaps(exons, 
                                        intron_ranges[secItrChoices[maxExpr]], 
                                        type = "within")) == 0){
                    # clear exon skipping, only exon is skipped 
                    # calculate frameshift, skipped exon plus possible exon 
                    #    elongation 
                    
                    shift = (-1)*(end(exons[exonChoices[1]]) - 
                                     start(exons[exonChoices[1]]) + 1) + 
                        ss_start - start(intron_ranges[secItrChoices[maxExpr]])
                    
                    frs = ifelse(shift %% 3 == 0,"unlikely","likely")
                    ifelse(shift_needed, 
                            return(c("singleExonSkipping", "inconclusive", 
                                        shift)), 
                            return(c("singleExonSkipping", frs)))
                }
            }
        } # single exon skipping end
        
    }
    
    # splice site longer than one intron + exon -> not defined for now
    ifelse(shift_needed, 
            return(c("exonSkipping", "inconclusive", 0)), 
            return(c("exonSkipping", "inconclusive")))
}

#' 
#' @noRd
compareEnds <- function(junctions_gr, i, max_lap, shift_needed, 
                            intron_ranges, exons){
    intron_end = end(intron_ranges[max_lap])
    ss_end = end(junctions_gr[i])
    
    # found the most freq intron with same start again
    # check if intron ends after splice site -> exon elongation -> FRS -> done
    if(intron_end > ss_end){
        if(((intron_end - ss_end) %% 3) != 0){
            frs = "likely"
        }else{ frs = "unlikely"}
        
        ifelse(shift_needed, 
                return(c("exonElongation", frs, (intron_end - ss_end))), 
                return(c("exonElongation", frs)))
    }
    
    # check if splice site ends in following exon -> exon truncation -> FRS
    if(intron_end < ss_end){
        
        # create dummy exon find all exons starting from that intron end
        dummy_exon <- GRanges(
            seqnames = toString(intron_ranges[max_lap]@seqnames@values),
            ranges = IRanges(intron_end + 1, end = intron_end + 2),
            strand = toString(intron_ranges[max_lap]@strand@values)
        )
        exonChoices <- to(findOverlaps(dummy_exon, exons, type = "start"))
        for(j in exonChoices){
            exon_end = end(exons[j])
            if(exon_end > ss_end){
                if((ss_end - start(exons[j]) + 1)%%3 != 0){
                    frs = "likely"
                }else{frs = "unlikely"}
                ifelse(shift_needed, 
                        return(c("exonTruncation",frs, 
                                    (-1)*(ss_end - start(exons[j]) + 1))), 
                        return(c("exonTruncation",frs)))
            }
        }
        
        # check for single exon skipping
        if(length(exonChoices) == 1){
            
            # check if there is no other exon within the first intron: 
            #    splice site end until exon end
            dummyFirstItr <- GRanges(
                seqnames = toString(seqnames(intron_ranges[max_lap])),
                ranges = IRanges(start(junctions_gr[i]), 
                                    start(exons[exonChoices[1]]) - 1),
                strand = toString(strand(intron_ranges[max_lap]))
            )
            
            if(length(findOverlaps(exons, dummyFirstItr, 
                                    type = "within")) > 0){
                # another exon is contained within the most freq used intron
                ifelse(shift_needed, 
                        return(c("exonSkipping", "inconclusive", 0)), 
                        return(c("exonSkipping", "inconclusive")))
            }
            
            
            secondItr <- GRanges(
                seqnames = toString(intron_ranges[max_lap]@seqnames@values),
                strand = toString(intron_ranges[max_lap]@strand@values),
                ranges = IRanges(end(exons[exonChoices[1]]) + 1, ss_end) 
                # end of exon + 1, end of aberrant junction
            )
            secItrChoices <- to(findOverlaps(secondItr, intron_ranges, 
                                                type = "start"))
            # only look at most used one
            expre <- sapply(secItrChoices, function(j){
                elementMetadata(intron_ranges[j])$medianCount
            })
            maxExpr <- which.max(expre)
            
            if(length(secItrChoices) == 0){
                ifelse(shift_needed, 
                        return(c("exonSkipping", "inconclusive", 0)), 
                        return(c("exonSkipping", "inconclusive")))
            }
            
            if(ss_end <= end(intron_ranges[secItrChoices[maxExpr]])){
                # check if there is no other exon in that range
                if(length(findOverlaps(exons, 
                                        intron_ranges[secItrChoices[maxExpr]], 
                                        type = "within")) == 0){
                    # clear exon skipping, only exon is skipped 
                    # calculate frameshift, skipped exon plus possible exon 
                    #    elongation at end
                    shift = (-1)*(end(exons[exonChoices[1]]) - 
                                        start(exons[exonChoices[1]]) + 1) + 
                        end(intron_ranges[secItrChoices[maxExpr]]) - ss_end
                    frs = ifelse(shift%%3 == 0,"unlikely","likely")
                    ifelse(shift_needed, 
                            return(c("singleExonSkipping", "inconclusive", 
                                        shift)), 
                            return(c("singleExonSkipping", frs)))
                }
            }
        } # single exon skipping end
        
        
    }
    
    # splice site longer than one intron + exon -> not defined for now
    ifelse(shift_needed, 
            return(c("exonSkipping", "inconclusive", 0)), 
            return(c("exonSkipping", "inconclusive")))
}

#' 
#' @noRd
checkIntergenic <- function(junctions_gr, i, refseq.genes){
    # check if start > 1000
    # start - 1000, end + 1000
    start = start(junctions_gr[i]) 
    # ifelse(start > 1000, start = start - 1000, start = 1)
    # if(start > 1000){
    #     start = start - 1000
    # }else{start = 1}
    
    end = end(junctions_gr[i])  #+ 1000
    if(start + 2 < end){
        start = start + 1
        end = end - 1
    }
    
    test_junction <- GRanges(
        seqnames = seqnames(junctions_gr[i]),
        ranges = IRanges(start, end),
        strand = strand(junctions_gr[i])
    )
    
    # overlap with introns and exon
    # IGNORE STRANDS? -> decided its not necessary
    
    # check if distance to nearest is > 1000 -> intergenic
    # otherwise up/downstream
    dist = min(distance(test_junction, refseq.genes), na.rm = T)
    if(dist > 0){
        # if(dist > 1000){
        #     print("intergenic")
        #     return(c("intergenic", "unlikely"))
        # }else{
        
        # find nearest and compare starts
        if(start(refseq.genes[nearest(junctions_gr[i], 
                                        refseq.genes)]) > start){
            ifelse(strand(junctions_gr[i]) == "+", 
                    return(c("upstream", "unlikely")), 
                    return(c("downstream", "unlikely")))
        }else{
            ifelse(strand(junctions_gr[i]) == "+", 
                    return(c("downstream", "unlikely")), 
                    return(c("upstream", "unlikely")))
        }
    }
    return(c("inconclusive", "inconclusive"))
    
    # if both lists == 0 return intergenic else inconclusive
    # return(c("inconclusive", "inconclusive"))
}

#' 
#' @noRd
checkExonSkipping <- function(junctions_dt, txdb){
    psi_positions <- which(junctions_dt$type != "theta")
    colnames(junctions_dt)[which(names(junctions_dt) == "STRAND")] <- "strand2"
    junctions_gr <- makeGRangesFromDataFrame(junctions_dt[psi_positions], 
                                                keep.extra.columns = T)
    seqlevelsStyle(txdb) <- seqlevelsStyle(junctions_gr)
    
    refseq.genes<- genes(txdb)
    
    exonSkip <- which(junctions_dt[psi_positions]$aberrantSpliceType %in% 
                            c("exonSkipping", "singleExonSkipping"))
    
    print("start checking exonSkipping")
    newSkip_results <- sapply(exonSkip, function(i){
        start = start(junctions_gr[i]) 
        end = end(junctions_gr[i])
        
        # reduce the junction width so adjacent genes have a distance of 1
        if(start + 2 < end){
            start = start + 1
            end = end - 1
        }
        
        test_start <- GRanges(
            seqnames = seqnames(junctions_gr[i]),
            strand = strand(junctions_gr[i]),
            ranges = IRanges(start, start + 1)
        )
        
        test_end <- GRanges(
            seqnames = seqnames(junctions_gr[i]),
            strand = strand(junctions_gr[i]),
            ranges = IRanges(end - 1, end)
        )
        
        # check for which genes distance to start is 0
        start_genes <- which(distance(test_start, refseq.genes) == 0)
        # start is not in a gene
        if(length(start_genes) == 0) return("beyondGene")
        
        # start is in a gene -> is end in same gene
        for(to in start_genes){
            # end is in same gene
            if(distance(test_end, refseq.genes[to]) == 0){
                return("exonSkipping")
            }
        }
        
        end_genes <- which(distance(test_end, refseq.genes) == 0)
        # end is not in a gene
        if(length(end_genes) == 0) return("beyondGene")
        # end is in a different gene
        return("multigenic")
    })
    
    print("checking exonSkipping done")
    if(length(exonSkip) > 0){
        junctions_dt[psi_positions[exonSkip], 
                        aberrantSpliceType2 := newSkip_results]
        junctions_dt[which(junctions_dt$aberrantSpliceType2 == "beyondGene"), 
                        aberrantSpliceType := "beyondGene"]
        junctions_dt[which(junctions_dt$aberrantSpliceType2 == "beyondGene"), 
                        causesFrameshift := "inconclusive"]
        junctions_dt[which(junctions_dt$aberrantSpliceType2 == "multigenic"), 
                        aberrantSpliceType := "multigenic"]
        junctions_dt[which(junctions_dt$aberrantSpliceType2 == "multigenic"), 
                        causesFrameshift := "inconclusive"]
        junctions_dt[, aberrantSpliceType2 := NULL]
    }
    
    colnames(junctions_dt)[which(names(junctions_dt) == "STRAND")] <- "strand2"
    return(junctions_dt)
}

#' 
#' @noRd
checkInconclusive <- function(junctions_dt, txdb){
    psi_positions <- which(junctions_dt$type != "theta")
    colnames(junctions_dt)[which(names(junctions_dt) == "STRAND")] <- "strand2"
    junctions_gr <- makeGRangesFromDataFrame(junctions_dt[psi_positions], 
                                                keep.extra.columns = T)
    seqlevelsStyle(txdb) <- seqlevelsStyle(junctions_gr)
    
    refseq.genes<- genes(txdb)
    
    inconclusive <- which(junctions_dt[psi_positions
                                        ]$aberrantSpliceType == "inconclusive")
    print("start checking inconclusive")
    
    inconclusive_results <- sapply(inconclusive, function(i){
        start = start(junctions_gr[i]) 
        end = end(junctions_gr[i])
        
        # reduce the junction width so adjacent genes have a distance of 1
        if(start + 2 < end){
            start = start + 1
            end = end - 1
        }
        
        test_start <- GRanges(
            seqnames = seqnames(junctions_gr[i]),
            strand = strand(junctions_gr[i]),
            ranges = IRanges(start, start + 1)
        )
        
        test_end <- GRanges(
            seqnames = seqnames(junctions_gr[i]),
            strand = strand(junctions_gr[i]),
            ranges = IRanges(end - 1, end)
        )
        
        # check for which genes distance to start is 0
        start_genes <- which(distance(test_start, refseq.genes) == 0)
        # start is not in a gene
        if(length(start_genes) == 0) return("beyondGene")
        
        # start is in a gene -> is end in same gene
        for(to in start_genes){
            # end is in same gene
            if(distance(test_end, refseq.genes[to]) == 0){
                return("inconclusive")
            } 
        }
        
        end_genes <- which(distance(test_end, refseq.genes) == 0)
        # end is not in a gene
        if(length(end_genes) == 0) return("beyondGene")
        # end is in a different gene
        return("multigenic")
    })
    
    colnames(junctions_dt)[which(names(junctions_dt) == "strand2")] <- "STRAND"
    print("done checking inconclusive")
    if(length(inconclusive) > 0){
        junctions_dt[psi_positions[inconclusive], 
                        aberrantSpliceType := inconclusive_results]
    } 
    
    return(junctions_dt)
}
